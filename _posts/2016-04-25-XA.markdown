---
layout: post
title:  "分布式事务"
date:   2016-04-25 20：30：23 +0800
categories: blog

---

我曾经在分布式事务探索了很久，找到了不少理论和方案。但是他们都或多或少都会存在一些问题，于是就有了这篇博文。
<p/>

常见两阶段提交

- 各数据库执行完SQL后向事务管理器发送“准备提交”消息。
- 在收到全部数据库的“准备提交”消息前，任何数据库执行SQL出错，都进行回滚。
- 当收到全部数据库的“准备提交”消息后，则发送提交事务指令。

照这样做理论上存在问题，在事务提交的时候也会存在问题，现在我们来证明一下。
<p/>
假定有2个数据库分别为：DB1、DB2。他们顺利执行了一些SQL。然后发出“准备提交”消息，但他们在真正提交的过程中可能存在问题。

- DB1成功提交，而DB2网络断开或故障。
- DB1成功提交，而DB2事务提交失败如：事务超时，违反唯一约束（其他事务先提交了）等情况。

根本原因是即使SQL执行成功后，也不能百分之百保证事务提交成功。所以当多个数据库事务提交时，存在部分成功，部分失败的可能性，此时对于已提交的事务是不能回滚的。其他X阶段方案也有类似问题。
<p/>
出现这种情况时，会导致数据不一致造成业务问题。除非不使用分布式事务，或者能用某种方法可以对已经提交的数据做补偿或逆向操作。
<p/>

下面提供两种方案
<p/>

场景一：跨行转账，招行账户A向建行账户B转账100元，账户A余额充足。<br/>
逻辑：

- 账户A余额 - 100。
- 账户B余额 + 100。


方案：

- 账户A扣款100元，记录转账日志、扣款成功、状态：未完成（事务提交）。 
	- 事务提交后，发送消息，向账户B打款。（推荐, 异步化）。
	- 控制事务隔离级别，保证扣款成功提交后，再处理向账户B打款逻辑。
- 由于账户A扣款100元成功，所以后续流程一定能走通。最终账户B是一定能收到款的。
- 处理向B打款逻辑，成功后，标记用户A的转账日记 状态：转账完成。
- 定时任务处理转账日志：状态：未完成 记录。保证处理异常时，后续能补偿处理（二次保证，但保证最终一致性）
- 建行收款业务需要保证幂等性，对相同一转账流水号。账户B余额+100，仅一次。（业务严谨，避免同一流水号收款多次。）

依据：在业务允许的范围内，对业务进行拆解，从而可以不使用分布式事务。业务上接受账户A扣款成功，账户B收款延迟的情况，反过来则不行，可以思考下为什么。<br/>
关键字：幂等性、最终一致性。


<p/>
场景二：同样是跨行转账，招行账户A向建行账户B转账100元，账户A余额充足。<br/>
逻辑：

- 账户A余额 - 100。
- 账户B余额 + 100。

方案：

- 账户A扣款100元，记录转账日志、扣款成功、状态：未完成（事务提交）。
- 在账户B收款操作出现异常时，对账户A做补偿操作，账户A余额+100。标记转账日志状态为：取消。（保证及时性）
- 定时任务处理转账超时的情况（如：账户A补偿操作失败），保证即使补偿失败时，最终钱也会退回到账户A（有一定延迟，但是保证最终一致性）
- 取消转账，需要保证幂等性，同一取消转转流水号，仅补偿一次，避免账户A补偿多次100的情况。（业务严谨）

依据：业务必须满足（可逆条件），即当账户A扣款成功后，对于后续账户A余额不论任何变化，如：账户C向账户A打款300。不会影响账户A余额的正确性<br />
关键字：补偿、幂等性、最终一致性。

<p/>
可逆条件解释：<br/>
如：账户A余额500。扣款100

- 后续（收款300）、（补偿100）等价于（补偿100）、（收款300）的最终余额是致一的，都为800。满足可逆条件允许做补偿操作。
- 假设有余额Double的业务。对于后续（余额\*2）、（补偿100）不等价（补偿100）、（余额\*2）。一个为900，一个为1000。不满足可逆条件。


<p/>
这两种方案有不同适用场景，显然银行类似方案一。

- 方案一：适用于一但完成第一个步骤（扣款），对于后续所有步骤（收款）出现任何异常都可以继续进行下去。
- 方案二：适用于一但后续任意步骤出错（收款），对于前面步骤（扣款）都需要回退。业务限制：需要满足可逆条件。

<p/>
有兴趣进一步讨论更好的方案，可以通过heyadong820[AT]hotmail.com联系我。
